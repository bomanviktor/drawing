{"message":"method `display` has a `&mut self` declaration in the impl, but not in the trait","code":{"code":"E0185","explanation":"An associated function for a trait was defined to be static, but an\nimplementation of the trait declared the same function to be a method (i.e., to\ntake a `self` parameter).\n\nErroneous code example:\n\n```compile_fail,E0185\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    // error, method `foo` has a `&self` declaration in the impl, but not in\n    // the trait\n    fn foo(&self) {}\n}\n```\n\nWhen a type implements a trait's associated function, it has to use the same\nsignature. So in this case, since `Foo::foo` does not take any argument and\ndoes not return anything, its implementation on `Bar` should be the same:\n\n```\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn foo() {} // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":849,"byte_end":900,"line_start":34,"line_end":34,"column_start":5,"column_end":56,"is_primary":true,"text":[{"text":"    fn display(&mut self, x: i32, y: i32, color: Color) {","highlight_start":5,"highlight_end":56}],"label":"`&mut self` used in impl","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/geometrical_shapes.rs","byte_start":144,"byte_end":156,"line_start":9,"line_end":9,"column_start":5,"column_end":17,"is_primary":false,"text":[{"text":"    fn display() {}","highlight_start":5,"highlight_end":17}],"label":"trait method declared without `&mut self`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0185]\u001b[0m\u001b[0m\u001b[1m: method `display` has a `&mut self` declaration in the impl, but not in the trait\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:34:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn display(&mut self, x: i32, y: i32, color: Color) {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`&mut self` used in impl\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0msrc/geometrical_shapes.rs:9:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn display() {}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mtrait method declared without `&mut self`\u001b[0m\n\n"}
{"message":"arguments to this method are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/draw.rs","byte_start":330,"byte_end":345,"line_start":9,"line_end":9,"column_start":21,"column_end":36,"is_primary":false,"text":[{"text":"                    self.x as usize,","highlight_start":21,"highlight_end":36}],"label":"expected `i32`, found `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/draw.rs","byte_start":367,"byte_end":382,"line_start":10,"line_end":10,"column_start":21,"column_end":36,"is_primary":false,"text":[{"text":"                    self.y as usize,","highlight_start":21,"highlight_end":36}],"label":"expected `i32`, found `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/draw.rs","byte_start":299,"byte_end":308,"line_start":8,"line_end":8,"column_start":18,"column_end":27,"is_primary":true,"text":[{"text":"                .set_pixel(","highlight_start":18,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/bao.ta/.cargo/registry/src/index.crates.io-6f17d22bba15001f/raster-0.2.0/src/image.rs","byte_start":6813,"byte_end":6822,"line_start":237,"line_end":237,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    pub fn set_pixel(&mut self, x: i32, y:i32, color: Color ) -> RasterResult<()> {","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `usize` to an `i32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src/draw.rs","byte_start":330,"byte_end":330,"line_start":9,"line_end":9,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"                    self.x as usize,","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/draw.rs","byte_start":345,"byte_end":345,"line_start":9,"line_end":9,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"                    self.x as usize,","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":").try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `usize` to an `i32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src/draw.rs","byte_start":367,"byte_end":367,"line_start":10,"line_end":10,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"                    self.y as usize,","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/draw.rs","byte_start":382,"byte_end":382,"line_start":10,"line_end":10,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"                    self.y as usize,","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":").try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: arguments to this method are incorrect\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/draw.rs:8:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                .set_pixel(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    self.x as usize,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `i32`, found `usize`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    self.y as usize,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `i32`, found `usize`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: method defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/bao.ta/.cargo/registry/src/index.crates.io-6f17d22bba15001f/raster-0.2.0/src/image.rs:237:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m237\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn set_pixel(&mut self, x: i32, y:i32, color: Color ) -> RasterResult<()> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m(\u001b[0m\u001b[0mself.x as usize\u001b[0m\u001b[0m\u001b[38;5;10m).try_into().unwrap()\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m(\u001b[0m\u001b[0mself.y as usize\u001b[0m\u001b[0m\u001b[38;5;10m).try_into().unwrap()\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++\u001b[0m\n\n"}
{"message":"arguments to this method are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/draw.rs","byte_start":1154,"byte_end":1165,"line_start":41,"line_end":41,"column_start":32,"column_end":43,"is_primary":false,"text":[{"text":"                    .set_pixel(x0 as usize, y0 as usize, raster::Color::rgb(255, 255, 255))","highlight_start":32,"highlight_end":43}],"label":"expected `i32`, found `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/draw.rs","byte_start":1167,"byte_end":1178,"line_start":41,"line_end":41,"column_start":45,"column_end":56,"is_primary":false,"text":[{"text":"                    .set_pixel(x0 as usize, y0 as usize, raster::Color::rgb(255, 255, 255))","highlight_start":45,"highlight_end":56}],"label":"expected `i32`, found `usize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/draw.rs","byte_start":1144,"byte_end":1153,"line_start":41,"line_end":41,"column_start":22,"column_end":31,"is_primary":true,"text":[{"text":"                    .set_pixel(x0 as usize, y0 as usize, raster::Color::rgb(255, 255, 255))","highlight_start":22,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/bao.ta/.cargo/registry/src/index.crates.io-6f17d22bba15001f/raster-0.2.0/src/image.rs","byte_start":6813,"byte_end":6822,"line_start":237,"line_end":237,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    pub fn set_pixel(&mut self, x: i32, y:i32, color: Color ) -> RasterResult<()> {","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `usize` to an `i32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src/draw.rs","byte_start":1154,"byte_end":1154,"line_start":41,"line_end":41,"column_start":32,"column_end":32,"is_primary":true,"text":[{"text":"                    .set_pixel(x0 as usize, y0 as usize, raster::Color::rgb(255, 255, 255))","highlight_start":32,"highlight_end":32}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/draw.rs","byte_start":1165,"byte_end":1165,"line_start":41,"line_end":41,"column_start":43,"column_end":43,"is_primary":true,"text":[{"text":"                    .set_pixel(x0 as usize, y0 as usize, raster::Color::rgb(255, 255, 255))","highlight_start":43,"highlight_end":43}],"label":null,"suggested_replacement":").try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `usize` to an `i32` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src/draw.rs","byte_start":1167,"byte_end":1167,"line_start":41,"line_end":41,"column_start":45,"column_end":45,"is_primary":true,"text":[{"text":"                    .set_pixel(x0 as usize, y0 as usize, raster::Color::rgb(255, 255, 255))","highlight_start":45,"highlight_end":45}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/draw.rs","byte_start":1178,"byte_end":1178,"line_start":41,"line_end":41,"column_start":56,"column_end":56,"is_primary":true,"text":[{"text":"                    .set_pixel(x0 as usize, y0 as usize, raster::Color::rgb(255, 255, 255))","highlight_start":56,"highlight_end":56}],"label":null,"suggested_replacement":").try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: arguments to this method are incorrect\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/draw.rs:41:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    .set_pixel(x0 as usize, y0 as usize, raster::Color::rgb(255, 255, 255))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `i32`, found `usize`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected `i32`, found `usize`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: method defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/bao.ta/.cargo/registry/src/index.crates.io-6f17d22bba15001f/raster-0.2.0/src/image.rs:237:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m237\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn set_pixel(&mut self, x: i32, y:i32, color: Color ) -> RasterResult<()> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    .set_pixel(\u001b[0m\u001b[0m\u001b[38;5;10m(\u001b[0m\u001b[0mx0 as usize\u001b[0m\u001b[0m\u001b[38;5;10m).try_into().unwrap()\u001b[0m\u001b[0m, y0 as usize, raster::Color::rgb(255, 255, 255))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `usize` to an `i32` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    .set_pixel(x0 as usize, \u001b[0m\u001b[0m\u001b[38;5;10m(\u001b[0m\u001b[0my0 as usize\u001b[0m\u001b[0m\u001b[38;5;10m).try_into().unwrap()\u001b[0m\u001b[0m, raster::Color::rgb(255, 255, 255))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++\u001b[0m\n\n"}
{"message":"aborting due to 3 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 3 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0185, E0308.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0185, E0308.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0185`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0185`.\u001b[0m\n"}
